<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>One File Web Chat</title>
    <link rel="stylesheet" href="https://unpkg.com/primeicons@7.0.0/primeicons.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/primevue@4.0.0-rc.2/umd/primevue.min.js"></script>
    <script src="https://unpkg.com/@primevue/themes@4.0.0-rc.2/umd/lara.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js"></script>
</head>

<body>
    <!-- GUI Part -->
    <div class="bg-gray-300">
        <div id="app">
            <div class="border border-gray-200 rounded-lg shadow">
                <p-tabs value="0">
                    <p-tablist>
                        <p-tab v-for="(c,i) in ['Home','Chat','Config','Help']" :value="`${i}`">{{c}}</p-tab>
                    </p-tablist>
                    <p-tabpanels>
                        <p-tabpanel value="0">
                            <div class="card" v-for="c in storage.all_chat()">
                                <br>
                                <p-button @click="selected_chat_uuid=c.uuid">{{c.uuid}}</p-button>
                            </div>
                        </p-tabpanel>

                        <p-tabpanel value="1">
                            <ul class="text-base">
                                <hr>
                                <li v-for="msg in [...storage.get_chat_msgs(selected_chat_uuid).msgs,ai_message]">
                                    <div v-if="msg.content&&msg.content.length>0">
                                        <div v-html="markdown_config.render(`**${msg.role}** : ${msg.content}`)"></div>
                                        <i class="pi pi-replay" @click="history_repush(msg)"></i>
                                        <i class="pi pi-trash" @click="()=>storage.del_msg(msg.uuid)"></i>
                                        <span class="italic text-xs">{{msg.timestamp}}</span>
                                        <hr>
                                    </div>
                                </li>
                            </ul>
                            <br>
                            <hr>
                            <hr><br>
                            <p-inputtext v-model="user_message.content"
                                placeholder="Type something for AI..."></p-inputtext>
                            <p-button label="Send" @click="sendmsg"></p-button>

                        </p-tabpanel>
                        <p-tabpanel value="2">
                            <div class="card" v-for="config in configs">
                                <label :for="config.name"> {{config.what}}</label>
                                <div v-if="config.type=='boolean'"><p-toggleswitch :inputId="config.name"
                                        v-model="config.val" @click="config.command" /></div>

                                <div v-else-if="config.type=='string'"><p-inputtext :id="config.name"
                                        v-model="config.val" /></div>

                                <div v-else-if="config.type=='number'"><p-inputnumber :id="config.name"
                                        v-model="config.val" mode="decimal" showButtons :min="0" :max="100" /></div>
                            </div>
                        </p-tabpanel>
                        <p-tabpanel value="3">
                            <div class="card">
                                <p v-for="conf in configs">{{conf}}</p>
                            </div>
                            <hr>
                            <div class="card">{{ openaibody() }}</div>
                            <hr>
                            <div class="card">{{ storage.get_chat_msgs(selected_chat_uuid) }}</div>
                        </p-tabpanel>
                    </p-tabpanels>
                </p-tabs>
            </div>
            <p-toast />
        </div>
    </div>

    <!-- Back end storage Part -->   
    <script>   
    const { createApp, ref } = Vue; 
    class SingletonStorageController {
            add_slave(slave) { this.model.slaves.push(slave); }

            _set_slaves(key, value) {
                this.model.slaves.forEach(slave => {
                    if (slave.set) { slave.set(key, value); }
                });
            }

            _delete_slaves(key) {
                this.model.slaves.forEach(slave => {
                    if (slave.delete) { slave.delete(key); }
                });
            }

            exists(key) { console.log(`[${this.constructor.name}]: not implemented`); }

            set(key, value) { console.log(`[${this.constructor.name}]: not implemented`); }

            get(key) { console.log(`[${this.constructor.name}]: not implemented`); }

            delete(key) { console.log(`[${this.constructor.name}]: not implemented`); }

            keys(pattern = '*') { console.log(`[${this.constructor.name}]: not implemented`); }

            clean() { this.keys('*').forEach(k => this.delete(k)); }

            dumps() { var res = {}; this.keys('*').forEach(k => res[k] = this.get(k)); return JSON.stringify(res); }

            loads(jsonString = '{}') { console.log('not implemented'); }
        }

        class SingletonVueStorage {
            static _instance = null;
            static _meta = {};

            constructor() {
                if (!SingletonVueStorage._instance) {
                    SingletonVueStorage._instance = this;
                    this.store = ref({});
                    this.store.get = ()=>this.store.value;
                    this.slaves = [];
                }
                return SingletonVueStorage._instance;
            }
        }

        class SingletonVueStorageController extends SingletonStorageController {
            constructor(model) {
                super();
                this.model = model;
            }

            exists(key) { return key in this.model.store.get(); }

            set(key, value) {
                this.model.store.get()[key] = value;
                this._set_slaves(key, value);
            }

            get(key) { return this.model.store.get()[key] || null; }

            delete(key) {
                if (key in this.model.store.get()) { delete this.model.store.get()[key]; }
                this._delete_slaves(key);
            }

            keys(pattern = '*') {
                const regex = new RegExp(pattern.replace(/\*/g, '.*'));
                return Object.keys(this.model.store.get()).filter(key => key.match(regex));
            }
        }

        class SingletonKeyValueStorage extends SingletonStorageController {
            constructor() {
                super();
                this.js_backend();
            }

            js_backend() { this.client = new SingletonVueStorageController(new SingletonVueStorage()); }

            exists(key) { return this.client.exists(key); }
            set(key, value) { this.client.set(key, value); }
            get(key) { return this.client.get(key); }
            delete(key) { this.client.delete(key); }
            keys(pattern = '*') { return this.client.keys(pattern); }
            clean() { this.client.clean(); }
            dump(jsonPath) { this.client.dump(jsonPath); }
            load(jsonPath) { this.client.load(jsonPath); }
            dumps() { return this.client.dumps(); }
            loads(jsonStr) { this.client.loads(jsonStr); }
        }
        // Tests for SingletonKeyValueStorage
        (async () => {
            console.log("Testing SingletonKeyValueStorage...");

            const storage = new SingletonKeyValueStorage();

            // Test 1: Set and Get
            storage.set('key1', { data: 'value1' });
            const value1 = storage.get('key1');
            console.assert(JSON.stringify(value1) === JSON.stringify({ data: 'value1' }), 'Test 1 Failed: Set or Get does not work correctly');

            // Test 2: Exists
            const exists1 = storage.exists('key1');
            const exists2 = storage.exists('key2');
            console.assert(exists1 === true, 'Test 2 Failed: Exists does not return true for existing key');
            console.assert(exists2 === false, 'Test 2 Failed: Exists does not return false for non-existing key');

            // Test 3: Delete
            storage.delete('key1');
            const valueAfterDelete = storage.get('key1');
            console.assert(valueAfterDelete === null, 'Test 3 Failed: Delete does not remove the key properly');

            // Test 4: Keys
            storage.set('test1', { data: '123' });
            storage.set('test2', { data: '456' });
            storage.set('something', { data: '789' });
            const keys = storage.keys('test*');
            console.assert(keys.includes('test1') && keys.includes('test2') && keys.length === 2, 'Test 4 Failed: Keys does not filter correctly');

            // Test 5: Clean
            storage.clean();
            const keysAfterClean = storage.keys('*');
            console.assert(keysAfterClean.length === 0, 'Test 5 Failed: Clean does not clear all keys');

            console.log("All tests completed.");
        })();
    </script>

    <!-- main Part -->   
    <script>
        const storage = new SingletonKeyValueStorage();
        const gen_uuid = (prefix = '') => {
                    return prefix + 'xxxx-xxxx-xxxx-xxxx-xxxx'.replace(/x/g, function () {
                        return Math.floor(Math.random() * 16).toString(16);
                    });
                }
        const get_now    = ()=>new Date().toISOString();
        storage.new_chat = ()=>{const uuid=`Chat:${gen_uuid()}`;storage.set(uuid,{title:uuid,msg_uuids:[],timestamp:get_now(),uuid:uuid});return storage.get(uuid)};
        storage.del_chat = (uuid)=>storage.delete(uuid);
        storage.get_chat = (uuid)=>storage.get(uuid);
        storage.get_chat_msgs = (chat_uuid)=>{return {...storage.get_chat(chat_uuid),msgs:storage.all_msgs(chat_uuid)}}
        storage.all_chat = (uuid)=>{return storage.keys('Chat:*').map(k=>storage.get_chat_msgs(k))};

        storage.get_msg = (uuid)=>storage.get(uuid);
        storage.add_msg = (chat_uuid,{role,content})=>{
            const uuid=`Message:${gen_uuid()}`;
            storage.get_chat(chat_uuid).msg_uuids.push(uuid);
            storage.set(uuid,{role:role,content:content,timestamp:get_now(),uuid:uuid,chat:chat_uuid});
        };
        storage.del_msg = (msg_uuid)=>{
            const msg=storage.get_msg(msg_uuid);
            const chat = storage.get_chat(msg.chat);
            chat.msg_uuids = chat.msg_uuids.filter(m_uuid=>m_uuid!=msg_uuid);
            storage.delete(msg_uuid);
        };
        storage.all_msgs = (chat_uuid)=>{
            const chat = storage.get_chat(chat_uuid);
            return chat?chat.msg_uuids.map(m_uuid=>storage.get_msg(m_uuid)):[];
        };

        /// mock
        {
            const chat = storage.new_chat();
            storage.add_msg(chat.uuid,{role:'user',content:'hi'});
            storage.add_msg(chat.uuid,{role:'assistant',content:'Yes sir!'});
        }        
        {
            const chat = storage.new_chat();
            storage.add_msg(chat.uuid,{role:'user',content:'ok'});
            storage.add_msg(chat.uuid,{role:'assistant',content:'well'});
        }

        const app = createApp({
            setup() {
                const mk_config = (name, val, what, command = () => { }) => {
                    return { name: name, val: val, what: what, command: command, type: typeof (val) };
                }
                const configs = ref([
                    mk_config('darkmode', false, 'Darkmode',
                        () => { document.getElementsByTagName('html')[0].classList.toggle('app-dark'); }),
                    mk_config('apikey', 'sk-', 'API Key'),
                    mk_config('sysp', 'You are a helpful assistant.', 'System Prompt'),
                    mk_config('modelname', 'gpt-3.5-turbo', 'Model Name'),
                    mk_config('sendlast', 4, 'Send last messages'),
                    mk_config('url', 'https://api.openai.com/v1/chat/completions', 'API URL'),
                ])
                configs.get = () => configs.value;
                configs.get().forEach(c => { configs.value[c.name] = c });

                const user_message = ref({ role: 'user', content: '' });
                const ai_message = ref({ role: 'assistant', content: '' });
                ai_message.get = () => ai_message.value;

                const history_dump = () => {
                    return {
                        model: configs.get().modelname.val, stream: true,
                        messages: [{ role: 'system', content: configs.get().sysp.val },
                        ...storage.get_chat_msgs(selected_chat_uuid.value).msgs],
                    }
                };

                const markdown_config = window.markdownit({
                    linkify: true, xhtmlOut: true, html: true, breaks: true,
                });
                const history_show = (msg) => {
                    return markdown_config.render(`**${msg.role}** : ${msg.content}`);
                }

                const sendmsg = () => {
                    storage.add_msg(selected_chat_uuid.value,user_message.value);
                    openaichat();
                };

                const history_repush = (msg) => {
                    storage.del_msg(msg.uuid)
                    user_message.value.content = msg.content;
                    sendmsg();
                }

                const toast = PrimeVue.useToast();

                const showInfo = (msg = 'Info Content', life = 1000) => {
                    toast.add({ severity: 'info', summary: 'Info', detail: msg, life: life });
                };

                const showError = (msg = 'Error Content', life = 5000) => {
                    console.error(msg);
                    toast.add({ severity: 'error', summary: 'Error', detail: msg, life: life });
                };

                const openaibody = () => {
                    const res = history_dump();
                    res.messages = [res.messages[0], ...res.messages.filter(m => m.timestamp).slice(-parseInt(configs.get().sendlast.val))]
                                    .map(m => { return { role: m.role, content: m.content } })
                    return JSON.stringify(res);
                }

                const openaichat = () => {
                    const body = openaibody();
                    const decoder = new TextDecoder('utf-8');
                    return fetch(configs.get().url.val, {
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${configs.get().apikey.val}`
                        }, method: 'POST', body: body
                    })
                        .then(response => {
                            if (!response.ok) { // Checks if the status code is outside of the 2xx range
                                switch (response.status) {
                                    case 400: throw new Error('Bad Request: The server could not understand the request.');
                                    case 401: throw new Error('Unauthorized: Please check your credentials.');
                                    case 403: throw new Error('Forbidden: You do not have permission to access this resource.');
                                    case 404: throw new Error('Not Found: The requested resource could not be found.');
                                    case 429: throw new Error('Too Many Requests: You have reached the rate limit.');
                                    case 500: throw new Error('Internal Server Error: The server encountered an unexpected condition.');
                                    case 503: throw new Error('Service Unavailable: The server is currently unable to handle the request.');
                                    default: throw new Error(`An error occurred: ${response.statusText}`);
                                }
                            }
                            return response.body.getReader();
                        }
                        )
                        .then(reader => {
                            ai_message.get().content = '';
                            const stream = new ReadableStream({
                                start(controller) {
                                    function push() {
                                        // Read from the stream
                                        reader.read().then(({ done, value }) => {
                                            // When no more data needs to be consumed, close the stream
                                            if (done) {
                                                controller.close();
                                                return;
                                            }
                                            const text = decoder.decode(value);
                                            const lines = text.split(/\n+/);
                                            for (const line of lines) {
                                                const json_text = line.replace(/^data:\s*/, '');
                                                if (json_text === '[DONE]') {
                                                    if (ai_message.get().content.length > 0) {
                                                        storage.add_msg(selected_chat_uuid.value,ai_message.value);
                                                        ai_message.get().content = '';
                                                    }
                                                    return;
                                                }
                                                if (json_text.length == 0) continue;
                                                const data = JSON.parse(json_text);
                                                const content = data.choices[0].delta.content;
                                                if (content) ai_message.get().content += content;
                                            }
                                            // Enqueue the next data chunk into our target stream
                                            controller.enqueue(value);
                                            push();
                                        }).catch(e => {
                                            showError(`${e.message}`);
                                            controller.error(e);
                                        });
                                    }
                                    push();
                                }
                            });
                            return new Response(stream, { headers: { "Content-Type": "text/plain" } }).text();
                        })
                        .catch(e => showError(`Failed to fetch: ${e.message}`));
                }
                const selected_chat_uuid = ref(storage.all_chat()[0].uuid);
                return {
                    storage, selected_chat_uuid, markdown_config,
                    configs, user_message, ai_message,
                    sendmsg, showInfo,  history_repush, history_dump, openaibody
                };
            },
        });

        app.use(PrimeVue.Config, {
            theme: {
                preset: PrimeVue.Themes.Lara,
                options: { prefix: 'p', darkModeSelector: '.app-dark', cssLayer: false, }
            }
        });
        app.use(PrimeVue.ToastService);

        app.directive('ripple', PrimeVue.Ripple);

        app.component('p-button', PrimeVue.Button);
        app.component('p-inputtext', PrimeVue.InputText);
        app.component('p-inputnumber', PrimeVue.InputNumber);
        app.component('p-tabs', PrimeVue.Tabs);
        app.component('p-tablist', PrimeVue.TabList);
        app.component('p-tab', PrimeVue.Tab);
        app.component('p-tabpanels', PrimeVue.TabPanels);
        app.component('p-tabpanel', PrimeVue.TabPanel);
        app.component('p-toast', PrimeVue.Toast);
        app.component('p-panel', PrimeVue.Panel);
        app.component('p-toggleswitch', PrimeVue.ToggleSwitch);

        app.mount('#app');
    </script>

</body>

</html>